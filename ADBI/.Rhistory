t.test(Credit$income,mu=50)
library(ISLR)
data(Credit)
force(Credit)
t.test(Credit$income,mu=50)
t.test(Credit$Income,mu=50)
t.test(Credit$Income,mu>=50)
t.test(Credit$Income,mu>50)
t.test(Credit$Income,mu=50)
View(Credit)
t.test(Credit$Income,mu=45)
t.test(Credit$Income,mu=45.21889)
t.test(Credit$Income,mu=50)
table(Credit$Married)
table_gender_married <- table(Credit$Gender,Credit$Married)
table_gender_married
chisq.test(table_gender_married)
jornal<-read.csv(".csv")
jornal<-read.csv("e.csv")
setwd("C:/Users/User01/OneDrive/Desktop/Iscte/ADBI/")
print(kmo_result)
cor_matrix <- cor(RH[, c("p1", "p2", "p3", "p4","p5", "p6","p7", "p8", "p9")])
kmo_result <- KMO(cor_matrix)
RH<-read.csv("Estudos_RS.csv")
cor_matrix <- cor(RH[, c("p1", "p2", "p3", "p4","p5", "p6","p7", "p8", "p9")])
kmo_result <- KMO(cor_matrix)
library(corrplot)
install.packages("psych")
install.packages("parameters")
library(psych)
library(ISLR)
install.packages("lawstat")
library("lawstat")
install.packages("dunn.test")
library(dunn.test)
library(corrplot)
install.packages("psych")
install.packages("parameters")
print(kmo_result)
RH<-read.csv("Estudos_RS.csv")
cor_matrix <- cor(RH[, c("p1", "p2", "p3", "p4","p5", "p6","p7", "p8", "p9")])
kmo_result <- KMO(cor_matrix)
library(ISLR)
install.packages("lawstat")
library("lawstat")
install.packages("dunn.test")
library(dunn.test)
library(corrplot)
install.packages("psych")
install.packages("parameters")
library(psych)
library(parameters)
library(ISLR)
library("lawstat")
library(dunn.test)
library(corrplot)
library(psych)
library(parameters)
setwd("C:/Users/User01/OneDrive/Desktop/Iscte/ADBI/")
RH<-read.csv("Estudos_RS.csv")
cor_matrix <- cor(RH[, c("p1", "p2", "p3", "p4","p5", "p6","p7", "p8", "p9")])
kmo_result <- KMO(cor_matrix)
print(kmo_result)
print(bartlett_result)
cortest.bartlett
print(bartlett_result)
#As variaveis são correlacionadas entre si oque
#As variaveis são correlacionadas entre si oque
bartlett_result <- cortest.bartlett(cor_matrix, n = nrow(RH))
print(bartlett_result)
pca_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")], nfactors = 9, rotate = "none")
# Criar tabela com resultados
pca_table <- data.frame(
Componente = 1:length(eigenvalues),
Valor_Proprio = eigenvalues,
Variância_Explicada = variances,
Variância_Acumulada = cum_variances)
print(pca_table)
pca_result <- principal(RH[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")], nfactors = 9, rotate = "none")
variances <- eigenvalues / sum(eigenvalues) * 100
# Tabela com valores próprios e variância
eigenvalues <- pca_result$values
variances <- eigenvalues / sum(eigenvalues) * 100
cum_variances <- cumsum(variances)
# Criar tabela com resultados
pca_table <- data.frame(
Componente = 1:length(eigenvalues),
Valor_Proprio = eigenvalues,
Variância_Explicada = variances,
Variância_Acumulada = cum_variances)
print(pca_table)
# Scree Plot
plot(pca_table$Componente, pca_table$Valor_Proprio,
type = "b",  # Linhas e pontos
main = "Scree Plot",
xlab = "Componente Principal",
ylab = "Valor Próprio (Eigenvalue)",
pch = 19) # Cor da linha e pontos
num_components <- 3
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums(loadings_retidos^2)
print(comunalidades_table)
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums
print(comunalidades_table)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
library(ISLR)
library("lawstat")
library(dunn.test)
library(corrplot)
library(psych)
library(parameters)
setwd("C:/Users/User01/OneDrive/Desktop/Iscte/ADBI/")
RH<-read.csv("Estudos_RS.csv")
cor_matrix <- cor(RH[, c("p1", "p2", "p3", "p4","p5", "p6","p7", "p8", "p9")])
kmo_result <- KMO(cor_matrix)
print(kmo_result)
bartlett_result <- cortest.bartlett(cor_matrix, n = nrow(RH))
print(bartlett_result)
#p-value < 0.05, logo rejeita se H0 de as var serem indepedentes
#As variaveis  são correlacionadas entre si, logo podemos usar todas as variaveis de p1 a p9 para a analise das componentes principais
pca_result <- principal(RH[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")], nfactors = 9, rotate = "none")
# Tabela com valores próprios e variância
eigenvalues <- pca_result$values
variances <- eigenvalues / sum(eigenvalues) * 100
cum_variances <- cumsum(variances)
# Criar tabela com resultados
pca_table <- data.frame(
Componente = 1:length(eigenvalues),
Valor_Proprio = eigenvalues,
Variância_Explicada = variances,
Variância_Acumulada = cum_variances)
print(pca_table)
# Scree Plot
plot(pca_table$Componente, pca_table$Valor_Proprio,
type = "b",  # Linhas e pontos
main = "Scree Plot",
xlab = "Componente Principal",
ylab = "Valor Próprio (Eigenvalue)",
pch = 19) # Cor da linha e pontos
num_components <- 3
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 3))
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Loadings antes da rotação (apenas componentes retidas)
loadings_antes <- pca_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_antes_table <- data.frame(round(loadings_antes, 2))
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Loadings depois da rotação
loadings_rotacao <- rotated_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_rotacao_table <- data.frame(round(loadings_rotacao, 2))
print(comunalidades_table)
# Número de componentes a reter
num_components <- 3
# Cargas fatoriais das componentes retidas
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums(loadings_retidos^2)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Loadings antes da rotação (apenas componentes retidas)
loadings_antes <- pca_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_antes_table <- data.frame(round(loadings_antes, 2))
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Guardar os scores no dataset original
df <- cbind(df, as.data.frame(rotated_result$scores))
# Loadings antes da rotação (apenas componentes retidas)
loadings_antes <- pca_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_antes_table <- data.frame(round(loadings_antes, 2))
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Aplicar rotação Varimax
rotated_result <- principal(df[c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Cargas fatoriais das componentes retidas
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums(loadings_retidos^2)
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
loadings_antes <- pca_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_antes_table <- data.frame(round(loadings_antes, 2))
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
# Loadings depois da rotação
loadings_rotacao <- rotated_result$loadings[, 1:num_components]
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")], nfactors = num_components, rotate = "varimax", cor = TRUE)
plot(pca_table$Componente, pca_table$Valor_Proprio,
type = "b",  # Linhas e pontos
main = "Scree Plot",
xlab = "Componente Principal",
ylab = "Valor Próprio (Eigenvalue)",
pch = 19) # Cor da linha e pontos
num_components <- 3
# Cargas fatoriais das componentes retidas
loadings_retidos <- pca_result$loadings[, 1:num_components]
# Comunalidades: Soma dos quadrados dos loadings das componentes retidas
comunalidades <- rowSums(loadings_retidos^2)
# Criar tabela de comunalidades
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
print(comunalidades_table)
# Loadings antes da rotação (apenas componentes retidas)
loadings_antes <- pca_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_antes_table <- data.frame(round(loadings_antes, 2))
# Aplicar rotação Varimax
rotated_result <- principal(df[, c("p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9")], nfactors = num_components, rotate = "varimax", cor = TRUE)
library(parameters)
df <- read.csv("Datasets/SaborUrbano.csv")
data <- read.csv("Datasets/SaborUrbano.csv")
head(data)
library(Amelia)
is.na(data)
plot(model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + MntMeat.Fish + MntDrinks + MntDesserts, data = data_for_model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + MntMeat.Fish + MntDrinks + MntDesserts, data = data_for_model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + MntMeat.Fish + MntDrinks + MntDesserts, data = data_for_model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + MntMeat.Fish + MntDrinks + MntDesserts, data = data_for_model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + MntMeat.Fish + MntDrinks + MntDesserts, data = data_for_model)
# Resumo do modelo
summary(model)
par(mfrow = c(2, 2))
plot(model)
plot(model)
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + Birthyear + MntDrinks + MntDesserts, data = data_for_model)
# Resumo do modelo
summary(model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "Birthyear", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
model <- lm(MntVegan.Vegetarian ~ Income + Birthyear + MntDrinks + MntDesserts, data = data_for_model)
# Resumo do modelo
summary(model)
numeric_data <- data[sapply(data, is.numeric)]
# Calcular a matriz de correlação
correlation_matrix <- cor(numeric_data, use = "complete.obs")
# Exibir a matriz de correlação
print(correlation_matrix)
numeric_data <- data[sapply(data, is.numeric)]
# Calcular a matriz de correlação
cor_matrix <- cor(numeric_data, use = "complete.obs")
kmo_result <- KMO(cor_matrix)
prop.table(table(Credit$Ethnicity))
cor_matrix <- cor(numeric_data, use = "complete.obs")
cov(cor_matrix)
library(corrplot)
cor_matrix
cor_matrix
plot(cor_matrix)
# Calcular a matriz de correlação
cor_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
addCoef.col = "black",
tl.col  = "black",
tl.srt = 45,
title = "Matriz de Correlação",
cex.main = 0.8
)
# Calcular a matriz de correlação
cor_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(
cor_matrix,
method = "color",
addCoef.col = "black",
tl.col  = "black",
tl.srt = 45,
title = "Matriz de Correlação",
cex.main = 0.8
)
# Exibir as variáveis com menor correlação
head(cor_df, 5)
numeric_data <- data[sapply(data, is.numeric)]
testModel <- lm(MntVegan.Vegetarian ~ . , data = numeric_data)
summary(testModel)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "Birthyear", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
# Resumo do modelo
summary(model)
data <- read.csv("Datasets/SaborUrbano.csv")
Sys.Date()
#ANO
format(Sys.Date(), format = "%Y")
#NOVA VARIÁVEL IDADE
data$Age <- as.numeric(format(Sys.Date(), format = "%Y")) - data$Birthyear
data$Age
head(data)
cor_matrix <- cor(data$Income,data$Birthyear, data$MntDrinks,data$MntDesserts)
selected_data <- data[, c("Income", "Birthyear", "MntDrinks", "MntDesserts")]
# Calcular a matriz de correlação
cor_matrix <- cor(selected_data, use = "complete.obs")
# Visualizar a matriz de correlação
corrplot(
cor_matrix,
method = "color",
addCoef.col = "black",
tl.col = "black",
tl.srt = 45,
title = "Matriz de Correlação",
cex.main = 0.8
)
selected_data <- data[, c("Income", "age", "MntDrinks", "MntDesserts")]
selected_data <- data[, c("Income", "age", "MntDrinks", "MntDesserts")]
selected_data <- data[, c("Income", "Age", "MntDrinks", "MntDesserts")]
# Calcular a matriz de correlação
cor_matrix <- cor(selected_data, use = "complete.obs")
# Visualizar a matriz de correlação
corrplot(
cor_matrix,
method = "color",
addCoef.col = "black",
tl.col = "black",
tl.srt = 45,
title = "Matriz de Correlação",
cex.main = 0.8
)
)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "Age", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
# Resumo do modelo
summary(model)
install.packages("performance")
library(performance)
check_collinearity(model)
data_for_model <- data[, c("MntVegan.Vegetarian", "Income", "MntMeat.Fish", "MntDrinks", "MntDesserts")]
# Ajustar o modelo de regressão linear múltipla
# Resumo do modelo
summary(model)
check_collinearity(model)
library(ISLR)
install.packages("lawstat")
library("lawstat")
install.packages("dunn.test")
library(dunn.test)
library(corrplot)
install.packages("psych")
install.packages("parameters")
library(psych)
library(parameters)
library(ISLR)
install.packages("lawstat")
library("lawstat")
install.packages("dunn.test")
library(dunn.test)
library(corrplot)
install.packages("psych")
install.packages("parameters")
library(psych)
library(parameters)
setwd("C:/Users/User01/OneDrive/Desktop/Iscte/ADBI/")
cor_matrix <- cor(data[, c("MntMeatFish", "MntEntries", "MntVeganVegetarian", "MntDrinks","MntDesserts", "MntAdditionalRequests")])
print(kmo_result)
bartlett_result <- cortest.bartlett(cor_matrix, n = nrow(jornal))
bartlett_result <- cortest.bartlett(cor_matrix, n = nrow(data))
print(bartlett_result)
pca_result <- principal(data[, c("MntMeatFish", "MntEntries", "MntVeganVegetarian",
"MntDrinks", "MntDesserts", "MntAdditionalRequests")],
nfactors = 6, rotate = "none")
pca_result <- principal(data[, c("MntMeatFish", "MntEntries", "MntVeganVegetarian","MntDrinks", "MntDesserts", "MntAdditionalRequests")],
nfactors = 6, rotate = "none")
# Ajustar os nomes das colunas no código
pca_result <- principal(data[, c("MntMeat.Fish", "MntEntries", "MntVegan.Vegetarian",
"MntDrinks", "MntDesserts", "MntAdditionalRequests")],
nfactors = 6, rotate = "none")
eigenvalues <- pca_result$values
variances <- eigenvalues / sum(eigenvalues) * 100
cum_variances <- cumsum(variances)
pca_table <- data.frame(
Componente = 1:length(eigenvalues),
Valor_Proprio = eigenvalues,
Variância_Explicada = variances,
Variância_Acumulada = cum_variances)
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
eigenvalues <- pca_result$values
variances <- eigenvalues / sum(eigenvalues) * 100
cum_variances <- cumsum(variances)
pca_table <- data.frame(
Componente = 1:length(eigenvalues),
Valor_Proprio = eigenvalues,
Variância_Explicada = variances,
Variância_Acumulada = cum_variances)
print(pca_table)
comunalidades_table <- data.frame(
Variável = rownames(pca_result$loadings),
Comunalidade = round(comunalidades, 2))
plot(pca_table$Componente, pca_table$Valor_Proprio,
type = "b", # Linhas e pontos
main = "Scree Plot",
xlab = "Componente Principal",
ylab = "Valor Próprio (Eigenvalue)",
pch = 19) # Cor da linha e pontos
rotated_result <- principal(data[, c("MntMeat.Fish", "MntEntries", "MntVegan.Vegetarian","MntDrinks", "MntDesserts", "MntAdditionalRequests")],
nfactors = num_components, rotate = "varimax", cor = TRUE)
loadings_rotacao <- rotated_result$loadings[, 1:num_components]
# Mostrar os loadings arredondados
loadings_rotacao_table <- data.frame(round(loadings_rotacao, 2))
print(loadings_rotacao_table)
data <- cbind(data, as.data.frame(rotated_result$scores))
vars_PC1 <- c("MntEntries", "MntDrinks", "MntDesserts")
vars_PC2 <- c("MntAdditionalRequests")
vars_PC3 <- c("MntMeat.Fish", "MntVegan.Vegetarian")
data$Indice_PC1 <- rowMeans(data[, vars_PC1], na.rm = TRUE)
data$Indice_PC2 <- rowMeans(data[, vars_PC2], na.rm = TRUE)
correlacao_PC3 <- cor(data$Indice_PC3, data$PC3)
head(data)
correlacao_PC1 <- cor(data$Indice_PC1, data$RC1)
correlacao_PC2 <- cor(data$Indice_PC2, data$RC2)
data$Indice_PC1 <- rowMeans(data[, vars_PC1], na.rm = TRUE)
data$Indice_PC2 <- rowMeans(data[, vars_PC2], na.rm = TRUE)
vars_PC1 <- c("MntEntries", "MntDrinks", "MntDesserts")
vars_PC2 <- c("MntAdditionalRequests")
vars_PC3 <- c("MntMeat.Fish", "MntVegan.Vegetarian")
data$Indice_PC1 <- rowMeans(data[, vars_PC1], na.rm = TRUE)
data$Indice_PC2 <- rowMeans(data[, vars_PC2], na.rm = TRUE)
vars_PC1 <- c("MntEntries", "MntDrinks", "MntDesserts")
vars_PC2 <- c("MntAdditionalRequests")
vars_PC3 <- c("MntMeat.Fish", "MntVegan.Vegetarian")
data$Indice_PC1 <- rowMeans(data[, vars_PC1], na.rm = TRUE)
data$Indice_PC3 <- data$MntAdditionalRequests
data$Indice_PC3 <- rowMeans(data[, vars_PC3], na.rm = TRUE)
correlacao_PC1 <- cor(data$Indice_PC1, data$RC1)
correlacao_PC2 <- cor(data$Indice_PC2, data$RC2)
head(data)
data$Indice_PC2 <- data$MntAdditionalRequests
correlacao_PC1 <- cor(data$Indice_PC1, data$RC1)
correlacao_PC2 <- cor(data$Indice_PC2, data$RC2)
correlacao_PC3 <- cor(data$Indice_PC3, data$RC3)
print(correlacao_PC1)
print(correlacao_PC2)
print(correlacao_PC3)
vars_PC1 <- c("MntEntries", "MntDrinks", "MntDesserts")
vars_PC2 <- c("MntAdditionalRequests")
vars_PC3 <- c("MntMeat.Fish", "MntVegan.Vegetarian")
data$Indice_PC1 <- rowMeans(data[, vars_PC1], na.rm = TRUE)
data$Indice_PC2 <- data$MntAdditionalRequests
data$Indice_PC3 <- rowMeans(data[, vars_PC3], na.rm = TRUE)
correlacao_PC1 <- cor(data$Indice_PC1, data$RC1)
correlacao_PC2 <- cor(data$Indice_PC2, data$RC2)
correlacao_PC3 <- cor(data$Indice_PC3, data$RC3)
print(correlacao_PC1)
print(correlacao_PC2)
print(correlacao_PC3)
head(data)
head(data)
